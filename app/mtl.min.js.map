{"version":3,"file":"mtl.min.js","sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/is-buffer/index.js","webpack:///./src/platforms/dd/dd-1.7.24.js","webpack:///./node_modules/buffer/index.js","webpack:///./node_modules/reconnecting-websocket/dist/reconnecting-websocket.mjs"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 151);\n","/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nmodule.exports = function (obj) {\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\n}\n\nfunction isBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\n}\n","/*!\n * \n * dd/v1.7.24\n * Mon Aug 20 2018 16:05:42 GMT+0800 (CST)\n * \n */\nvar my =\n    /******/\n    (function(modules) { // webpackBootstrap\n        /******/ // The module cache\n        /******/\n        var installedModules = {};\n        /******/\n        /******/ // The require function\n        /******/\n        function __webpack_require__(moduleId) {\n            /******/\n            /******/ // Check if module is in cache\n            /******/\n            if (installedModules[moduleId]) {\n                /******/\n                return installedModules[moduleId].exports;\n                /******/\n            }\n            /******/ // Create a new module (and put it into the cache)\n            /******/\n            var module = installedModules[moduleId] = {\n                /******/\n                i: moduleId,\n                /******/\n                l: false,\n                /******/\n                exports: {}\n                /******/\n            };\n            /******/\n            /******/ // Execute the module function\n            /******/\n            modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n            /******/\n            /******/ // Flag the module as loaded\n            /******/\n            module.l = true;\n            /******/\n            /******/ // Return the exports of the module\n            /******/\n            return module.exports;\n            /******/\n        }\n        /******/\n        /******/\n        /******/ // expose the modules object (__webpack_modules__)\n        /******/\n        __webpack_require__.m = modules;\n        /******/\n        /******/ // expose the module cache\n        /******/\n        __webpack_require__.c = installedModules;\n        /******/\n        /******/ // define getter function for harmony exports\n        /******/\n        __webpack_require__.d = function(exports, name, getter) {\n            /******/\n            if (!__webpack_require__.o(exports, name)) {\n                /******/\n                Object.defineProperty(exports, name, { enumerable: true, get: getter });\n                /******/\n            }\n            /******/\n        };\n        /******/\n        /******/ // define __esModule on exports\n        /******/\n        __webpack_require__.r = function(exports) {\n            /******/\n            if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n                /******/\n                Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n                /******/\n            }\n            /******/\n            Object.defineProperty(exports, '__esModule', { value: true });\n            /******/\n        };\n        /******/\n        /******/ // create a fake namespace object\n        /******/ // mode & 1: value is a module id, require it\n        /******/ // mode & 2: merge all properties of value into the ns\n        /******/ // mode & 4: return value when already ns object\n        /******/ // mode & 8|1: behave like require\n        /******/\n        __webpack_require__.t = function(value, mode) {\n            /******/\n            if (mode & 1) value = __webpack_require__(value);\n            /******/\n            if (mode & 8) return value;\n            /******/\n            if ((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n            /******/\n            var ns = Object.create(null);\n            /******/\n            __webpack_require__.r(ns);\n            /******/\n            Object.defineProperty(ns, 'default', { enumerable: true, value: value });\n            /******/\n            if (mode & 2 && typeof value != 'string')\n                for (var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n            /******/\n            return ns;\n            /******/\n        };\n        /******/\n        /******/ // getDefaultExport function for compatibility with non-harmony modules\n        /******/\n        __webpack_require__.n = function(module) {\n            /******/\n            var getter = module && module.__esModule ?\n                /******/\n                function getDefault() { return module['default']; } :\n                /******/\n                function getModuleExports() { return module; };\n            /******/\n            __webpack_require__.d(getter, 'a', getter);\n            /******/\n            return getter;\n            /******/\n        };\n        /******/\n        /******/ // Object.prototype.hasOwnProperty.call\n        /******/\n        __webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n        /******/\n        /******/ // __webpack_public_path__\n        /******/\n        __webpack_require__.p = \"\";\n        /******/\n        /******/\n        /******/ // Load entry module and return exports\n        /******/\n        return __webpack_require__(__webpack_require__.s = \"./src/web-view/embed/index.tsx\");\n        /******/\n    })\n    /************************************************************************/\n    /******/\n    ({\n\n        /***/\n        \"./node_modules/babel-runtime-loose/helpers/extends.js\":\n        /*!*************************************************************!*\\\n          !*** ./node_modules/babel-runtime-loose/helpers/extends.js ***!\n          \\*************************************************************/\n        /*! no static exports found */\n        /***/\n            (function(module, exports) {\n\n            var slice = Array.prototype.slice;\n\n            module.exports = function _extends(to) {\n                var from = slice.call(arguments, 1);\n                from.forEach(function t(f) {\n                    if (f && typeof(f) === 'object') {\n                        Object.keys(f).forEach(function tt(k) {\n                            to[k] = f[k];\n                        });\n                    }\n                });\n                return to;\n            };\n\n\n            /***/\n        }),\n\n        /***/\n        \"./src/bridge/shared/BizCustomAP.tsx\":\n        /*!*******************************************!*\\\n          !*** ./src/bridge/shared/BizCustomAP.tsx ***!\n          \\*******************************************/\n        /*! exports provided: default */\n        /***/\n            (function(module, __webpack_exports__, __webpack_require__) {\n\n            \"use strict\";\n            __webpack_require__.r(__webpack_exports__);\n\n            function doOpenTaobao(callBridge, url, login, result) {\n                if ('installed' in result) {\n                    if (result.installed) {\n                        if (login) {\n                            callBridge('getLoginToken', {}, function(res) {\n                                var loginToken = null;\n                                var encrypted = false;\n                                if ('token' in res && res.token !== '') {\n                                    loginToken = res.token;\n                                    encrypted = res.encrypted;\n                                }\n                                if (loginToken) {\n                                    url += '&loginToken=' + loginToken + '&tokenEncrypted=' + encrypted;\n                                }\n                                callBridge('openInBrowser', {\n                                    url: url\n                                });\n                            });\n                        } else {\n                            callBridge('openInBrowser', {\n                                url: url\n                            });\n                        }\n                    } else {\n                        callBridge('openInBrowser', {\n                            url: 'https://h5.m.taobao.com/bcec/downloadTaobao.html'\n                        });\n                    }\n                }\n            }\n            /* harmony default export */\n            __webpack_exports__[\"default\"] = (function(fn) {\n                return {\n                    d: function d(opt) {\n                        var callBridge = fn();\n                        callBridge('isInstalledApp', {\n                            packagename: 'com.taobao.taobao',\n                            scheme: 'taobao://'\n                        }, function(res) {\n                            doOpenTaobao(callBridge, opt.url, opt.login, res);\n                        });\n                    }\n                };\n            });\n\n            /***/\n        }),\n\n        /***/\n        \"./src/bridge/shared/Location.tsx\":\n        /*!****************************************!*\\\n          !*** ./src/bridge/shared/Location.tsx ***!\n          \\****************************************/\n        /*! exports provided: openLocation */\n        /***/\n            (function(module, __webpack_exports__, __webpack_require__) {\n\n            \"use strict\";\n            __webpack_require__.r(__webpack_exports__);\n            /* harmony export (binding) */\n            __webpack_require__.d(__webpack_exports__, \"openLocation\", function() { return openLocation; });\n            var openLocation = {\n                b: function b(opt) {\n                    opt.scale = opt.scale || 15; // é»˜è®¤ç¼©æ”¾15çº§\n                    opt.hidden = '1';\n                }\n            };\n\n            /***/\n        }),\n\n        /***/\n        \"./src/bridge/shared/Media.tsx\":\n        /*!*************************************!*\\\n          !*** ./src/bridge/shared/Media.tsx ***!\n          \\*************************************/\n        /*! exports provided: chooseImage, previewImage */\n        /***/\n            (function(module, __webpack_exports__, __webpack_require__) {\n\n            \"use strict\";\n            __webpack_require__.r(__webpack_exports__);\n            /* harmony export (binding) */\n            __webpack_require__.d(__webpack_exports__, \"chooseImage\", function() { return chooseImage; });\n            /* harmony export (binding) */\n            __webpack_require__.d(__webpack_exports__, \"previewImage\", function() { return previewImage; });\n            /* harmony import */\n            var _utils_bridge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ../../utils/bridge */ \"./src/utils/bridge.tsx\");\n\n            var chooseImage = {\n                b: function b(opt) {\n                    opt.count = opt.count || 1;\n                    if (typeof opt.sourceType === 'string') {\n                        opt.sourceType = [opt.sourceType];\n                    }\n                },\n                a: function a(res) {\n                    Object(_utils_bridge__WEBPACK_IMPORTED_MODULE_0__[\"mapping\"])(res, {\n                        errorCode: 'error',\n                        errorDesc: 'errorMessage',\n                        localIds: 'apFilePaths',\n                        tempFilePaths: 'apFilePaths'\n                    });\n                    // android è¿”å›žå­—ç¬¦ä¸²\n                    if (typeof res.apFilePaths === 'string') {\n                        res.apFilePaths = JSON.parse(res.apFilePaths);\n                    }\n                }\n            };\n            var previewImage = {\n                m: 'imageViewer',\n                b: function b(opt) {\n                    Object(_utils_bridge__WEBPACK_IMPORTED_MODULE_0__[\"mapping\"])(opt, {\n                        current: 'init%d'\n                    });\n                    // å¤„ç†é»˜è®¤ç´¢å¼•\n                    if (!opt.init) {\n                        opt.init = 0;\n                    }\n                    // å¤„ç†å›¾ç‰‡é“¾æŽ¥\n                    opt.images = [];\n                    (opt.urls || []).forEach(function(url) {\n                        opt.images.push({\n                            u: url\n                        });\n                    });\n                    delete opt.urls;\n                }\n            };\n\n            /***/\n        }),\n\n        /***/\n        \"./src/bridge/shared/Network.tsx\":\n        /*!***************************************!*\\\n          !*** ./src/bridge/shared/Network.tsx ***!\n          \\***************************************/\n        /*! exports provided: getNetworkType */\n        /***/\n            (function(module, __webpack_exports__, __webpack_require__) {\n\n            \"use strict\";\n            __webpack_require__.r(__webpack_exports__);\n            /* harmony export (binding) */\n            __webpack_require__.d(__webpack_exports__, \"getNetworkType\", function() { return getNetworkType; });\n            var getNetworkType = {\n                a: function a(res) {\n                    if (res.networkInfo) {\n                        res.networkType = res.networkInfo.toUpperCase();\n                    }\n                }\n            };\n\n            /***/\n        }),\n\n        /***/\n        \"./src/bridge/shared/UI.tsx\":\n        /*!**********************************!*\\\n          !*** ./src/bridge/shared/UI.tsx ***!\n          \\**********************************/\n        /*! exports provided: alert, showLoading, hideLoading */\n        /***/\n            (function(module, __webpack_exports__, __webpack_require__) {\n\n            \"use strict\";\n            __webpack_require__.r(__webpack_exports__);\n            /* harmony export (binding) */\n            __webpack_require__.d(__webpack_exports__, \"alert\", function() { return alert; });\n            /* harmony export (binding) */\n            __webpack_require__.d(__webpack_exports__, \"showLoading\", function() { return showLoading; });\n            /* harmony export (binding) */\n            __webpack_require__.d(__webpack_exports__, \"hideLoading\", function() { return hideLoading; });\n            /* harmony import */\n            var _utils_bridge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ../../utils/bridge */ \"./src/utils/bridge.tsx\");\n\n            var alert = {\n                b: function b(opt) {\n                    Object(_utils_bridge__WEBPACK_IMPORTED_MODULE_0__[\"mapping\"])(opt, {\n                        content: 'message%s',\n                        buttonText: 'button%s'\n                    });\n                }\n            };\n            var showLoading = {\n                b: function b(opt) {\n                    Object(_utils_bridge__WEBPACK_IMPORTED_MODULE_0__[\"mapping\"])(opt, {\n                        content: 'text%s'\n                    });\n                }\n            };\n            var hideLoading = {};\n\n            /***/\n        }),\n\n        /***/\n        \"./src/utils/bridge.tsx\":\n        /*!******************************!*\\\n          !*** ./src/utils/bridge.tsx ***!\n          \\******************************/\n        /*! exports provided: toType, mapping, apCallback */\n        /***/\n            (function(module, __webpack_exports__, __webpack_require__) {\n\n            \"use strict\";\n            __webpack_require__.r(__webpack_exports__);\n            /* harmony export (binding) */\n            __webpack_require__.d(__webpack_exports__, \"toType\", function() { return toType; });\n            /* harmony export (binding) */\n            __webpack_require__.d(__webpack_exports__, \"mapping\", function() { return mapping; });\n            /* harmony export (binding) */\n            __webpack_require__.d(__webpack_exports__, \"apCallback\", function() { return apCallback; });\n            /* harmony import */\n            var _objectKeys__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./objectKeys */ \"./src/utils/objectKeys.tsx\");\n\n            /**\n             * æ‹†åˆ†ç±»åž‹é”®åé‡ŒçœŸæ­£çš„ key å’Œå¯¹åº”çš„ type\n             * @method _separateTypeKey\n             * @param  {String}         key å¸¦ç±»åž‹æ ‡è¯†çš„é”®å\n             * @return {Object}             è¿”å›žé”®åå’Œç±»åž‹æ ‡è¯†ä¸¤ä¸ªå­—æ®µï¼Œ\n             *                              å¦‚{k: 'content', t: '%s'}\n             */\n            function _separateTypeKey(key) {\n                var matches = (key || '').match(/(\\w+)(%\\w)$/i);\n                var tk = {\n                    k: key\n                };\n                if (matches) {\n                    tk.k = matches[1];\n                    tk.t = matches[2];\n                }\n                return tk;\n            }\n            /**\n             * è¶…çº§å­—ç¬¦ä¸²è½¬æ¢\n             */\n            function __superToString(content) {\n                var str = content;\n                if (typeof content === 'object') {\n                    str = JSON.stringify(content);\n                } else {\n                    str = content + '';\n                }\n                return str;\n            }\n            /**\n             * 16è¿›åˆ¶é¢œè‰²è½¬æˆ10è¿›åˆ¶æ•°å­—\n             * @method __h2dColor\n             * @param  {String}   hex 16è¿›åˆ¶é¢œè‰²å­—ç¬¦ä¸²\n             * @return {Number}       10è¿›åˆ¶æ•°å­—\n             */\n            function __h2dColor(hex) {\n                var dec = '' + hex;\n                // å¦‚æžœåŠ äº†#å·ï¼ŒåŽ»æŽ‰\n                if (dec.indexOf('#') === 0) {\n                    dec = dec.substr(1);\n                }\n                // å¦‚æžœæ˜¯3ä½ç®€å†™ï¼Œè¡¥å…¨æˆ6ä½\n                if (dec.length === 3) {\n                    dec = dec.replace(/(.)/g, '$1$1');\n                }\n                dec = parseInt(dec, 16);\n                if (isNaN(dec)) {\n                    console.error(hex + ' is invalid hex color.');\n                }\n                return dec;\n            }\n            /**\n             * ç§»é™¤ base64 æ•°æ®å¤´ï¼Œnative æŽ¥å£ä¸éœ€è¦ä¼ å…¥å¤´éƒ¨\n             * @method __removeBase64Head\n             * @param  {String}           base64 æœ‰å¤´æ•°æ®\n             * @return {String}                  æ— å¤´æ•°æ®\n             */\n            function __removeBase64Head(base64) {\n                if (typeof base64 === 'string') {\n                    base64 = base64.replace(/^data:(\\/|\\w|\\-|\\.)+;base64,/i, '');\n                }\n                return base64;\n            }\n            /**\n             * æŠŠå€¼è½¬æ¢æˆç›¸åº”ç±»åž‹\n             * @method toType\n             * @param  {String} type  ç±»åž‹æ ‡è¯†ï¼Œç›®å‰æ”¯æŒ\n             *                        %s(å­—ç¬¦ä¸²)\n             *                        %c(16è½¬10è¿›åˆ¶é¢œè‰²)\n             *                        %h(10è½¬16è¿›åˆ¶é¢œè‰²)\n             *                        %b(ç§»é™¤ base64 æ•°æ®æ ¼å¼å¤´)\n             *                        %a{mimeType}(æ·»åŠ  base64 æ•°æ®å¤´)\n             *                        %d(æ•´æ•°)\n             *                        %f(æµ®ç‚¹æ•°)\n             * @param  {any} value å¾…è½¬æ¢å€¼ï¼Œç±»åž‹æœªçŸ¥\n             * @return {any}       è½¬æ¢å¥½çš„ç›¸åº”ç±»åž‹çš„\n             */\n            function toType(type, value) {\n                if (type === '%s') {\n                    value = __superToString(value);\n                } else if (type === '%c') {\n                    value = __h2dColor(value);\n                } else if (type === '%b') {\n                    value = __removeBase64Head(value);\n                } else if (type === '%d') {\n                    value = parseInt(value, 10);\n                } else if (type === '%f') {\n                    value = parseFloat(value);\n                }\n                return value;\n            }\n            /**\n             * å¤„ç†å¯¹è±¡æ˜ å°„å…³ç³»\n             * @method _mapping\n             * @param  {Object}  tObj åŽŸå§‹ç›®æ ‡å¯¹è±¡\n             * @param  {Object}  map æ˜ å°„å…³ç³»ï¼Œå¦‚{content: 'text'}ï¼Œ\n             *                       å³æŠŠ sObj.content çš„å€¼èµ‹ç»™ tObj.textï¼Œ\n             *                       å¹¶åˆ é™¤ tObj çš„ content å±žæ€§ï¼Œ\n             *                       æ‰€ä»¥ content å°±æ˜¯ sKeyï¼Œtext å°±æ˜¯ tKeyã€‚\n             *                       å¯ä»¥æŠŠ map å¯¹è±¡ä¸­çš„å†’å·(:)ç†è§£æˆ toï¼Œ\n             *                       å³ {content to text}ã€‚\n             *                       å…¶ä¸­ tKey çš„å€¼çš„æœ€åŽå¯ä»¥åŠ  %s ç­‰ç±»åž‹æ ‡è¯†è½¬æ¢æˆç›¸åº”ç±»åž‹ï¼Œ\n             *                       æ³¨æ„ï¼šè¦åŠ åˆ° æœ€åŽèµ‹å€¼ç»™ tObj çš„ é‚£ä¸ª tKey çš„åŽé¢ã€‚\n             *                       è¿™ä¹ˆåšçš„ç›®çš„æ˜¯å› ä¸ºï¼š\n             *                       æœ‰äº›æŽ¥å£çš„å…¥å‚å­—æ®µç›´æŽ¥ä¼ å…¥ éžå­—ç¬¦ä¸² å€¼æ—¶ï¼ŒæŽ¥å£å®Œå…¨æ— å“åº”ï¼Œ\n             *                       æ¯”å¦‚ AlipayJSBridge.call('alert',{message: 12345})\n             *\n             * @param  {Object} sObj å‚ç…§æ¥æºå¯¹è±¡\n             * @return {Object}     å¤„ç†æ˜ å°„åŽçš„ tObj\n             */\n            function mapping(tObj, map, sObj) {\n                var typeKey = void 0;\n                sObj = sObj || {};\n                Object(_objectKeys__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(map).forEach(function(sKey) {\n                    var tKey = map[sKey];\n                    typeKey = _separateTypeKey(tKey);\n                    // ç›®æ ‡ key\n                    tKey = typeKey.k;\n                    // æ˜ å°„æ¡ä»¶ï¼Œå¦åˆ™ä¸èµ‹å€¼ï¼Œé¿å…æ·»åŠ  value ä¸º undefined çš„ key\n                    if (tKey !== undefined && ( // ç›®æ ‡ key å®šä¹‰è¿‡\n                            sKey in tObj || sKey in sObj) && // æºæ•°æ®è‡³å°‘æœ‰ä¸€ä¸ªæœ‰æ•ˆ\n                        tObj[tKey] === undefined // ç›®æ ‡æ•°æ®ç©ºç¼ºå¾…èµ‹å€¼\n                    ) {\n                        // sKey æ—¢å¯ä»¥æ˜¯ sObj çš„ï¼Œä¹Ÿå¯ä»¥æ˜¯ tObj è‡ªå·±çš„ï¼Œä½†sObj ä¼˜å…ˆçº§é«˜äºŽåŽŸå§‹ tObj\n                        // å³ sObj[sKey]çš„å€¼ ä¼šè¦†ç›– tObj[sKey]çš„å€¼\n                        // å¹¶ä¸”è¦æ ¹æ® type å ä½ç¬¦åšç›¸åº”ç±»åž‹è½¬æ¢\n                        tObj[tKey] = toType(typeKey.t, sObj[sKey] === undefined ? tObj[sKey] : sObj[sKey]);\n                        // åˆ é™¤åŽŸå§‹ tObj ä¸­çš„ sKeyï¼ŒtKey å’Œ sKey åŒåæ—¶ä¸åšåˆ é™¤\n                        if (tKey !== sKey) {\n                            delete tObj[sKey];\n                        }\n                    }\n                });\n                return tObj;\n            }\n\n            function apCallback() {\n                var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n                var res = arguments[1];\n                var complete = params.complete,\n                    success = params.success,\n                    fail = params.fail;\n\n                if (res && res.error) {\n                    if (fail) {\n                        fail(res);\n                    }\n                } else {\n                    if (success) {\n                        success(res);\n                    }\n                }\n                if (complete) {\n                    complete(res);\n                }\n            }\n\n            /***/\n        }),\n\n        /***/\n        \"./src/utils/objectKeys.tsx\":\n        /*!**********************************!*\\\n          !*** ./src/utils/objectKeys.tsx ***!\n          \\**********************************/\n        /*! exports provided: default */\n        /***/\n            (function(module, __webpack_exports__, __webpack_require__) {\n\n            \"use strict\";\n            __webpack_require__.r(__webpack_exports__);\n            /* harmony export (binding) */\n            __webpack_require__.d(__webpack_exports__, \"default\", function() { return objectKeys; });\n\n            function objectKeys(obj) {\n                if (obj && typeof obj === 'object') {\n                    return Object.keys(obj);\n                }\n                return [];\n            }\n\n            /***/\n        }),\n\n        /***/\n        \"./src/utils/system.tsx\":\n        /*!******************************!*\\\n          !*** ./src/utils/system.tsx ***!\n          \\******************************/\n        /*! exports provided: systemVersion, ddSystemVersion, UCVersion, isAndroid, isIOS, isIDE, SDKVersion, compareVersion, logSystemInfo, compareSystemVersion, compareUCVersion, compareDDSysVersion */\n        /***/\n            (function(module, __webpack_exports__, __webpack_require__) {\n\n            \"use strict\";\n            __webpack_require__.r(__webpack_exports__);\n            /* harmony export (binding) */\n            __webpack_require__.d(__webpack_exports__, \"systemVersion\", function() { return systemVersion; });\n            /* harmony export (binding) */\n            __webpack_require__.d(__webpack_exports__, \"ddSystemVersion\", function() { return ddSystemVersion; });\n            /* harmony export (binding) */\n            __webpack_require__.d(__webpack_exports__, \"UCVersion\", function() { return UCVersion; });\n            /* harmony export (binding) */\n            __webpack_require__.d(__webpack_exports__, \"isAndroid\", function() { return isAndroid; });\n            /* harmony export (binding) */\n            __webpack_require__.d(__webpack_exports__, \"isIOS\", function() { return isIOS; });\n            /* harmony export (binding) */\n            __webpack_require__.d(__webpack_exports__, \"isIDE\", function() { return isIDE; });\n            /* harmony export (binding) */\n            __webpack_require__.d(__webpack_exports__, \"SDKVersion\", function() { return SDKVersion; });\n            /* harmony export (binding) */\n            __webpack_require__.d(__webpack_exports__, \"compareVersion\", function() { return compareVersion; });\n            /* harmony export (binding) */\n            __webpack_require__.d(__webpack_exports__, \"logSystemInfo\", function() { return logSystemInfo; });\n            /* harmony export (binding) */\n            __webpack_require__.d(__webpack_exports__, \"compareSystemVersion\", function() { return compareSystemVersion; });\n            /* harmony export (binding) */\n            __webpack_require__.d(__webpack_exports__, \"compareUCVersion\", function() { return compareUCVersion; });\n            /* harmony export (binding) */\n            __webpack_require__.d(__webpack_exports__, \"compareDDSysVersion\", function() { return compareDDSysVersion; });\n            var ua = navigator.userAgent || navigator.swuserAgent;\n            var _systemVersion = ua.match(/AlipayClient\\/(\\d+\\.\\d+\\.\\d+)/);\n            var _UCVersion = ua.match(/UCBS\\/(\\d+\\.\\d+)/);\n            var _ddVersion = ua.match(/DingTalk\\/([\\d\\.]+)/);\n            // expose all functions for ant fortune app\n            var systemVersion = _systemVersion && _systemVersion[1] || '100.0.0';\n            var ddSystemVersion = _ddVersion && _ddVersion[1] || '100.0.0';\n            var UCVersion = _UCVersion && _UCVersion[1] || '2.12';\n            var isAndroid = ua.indexOf('Android') > -1;\n            var isIOS = !isAndroid;\n            var isIDE = ua.indexOf('AlipayIDE') > -1;\n            var SDKVersion = \"1.7.24\" + '';\n            var caches = {};\n            var cacheIntArray = {};\n\n            function toIntArray(v) {\n                if (cacheIntArray[v]) {\n                    return cacheIntArray[v];\n                }\n                var ret = [];\n                var version = v.split('.');\n                for (var i = 0; i < version.length; i++) {\n                    ret.push(parseInt(version[i], 10));\n                }\n                cacheIntArray[v] = ret;\n                return ret;\n            }\n\n            function compareVersion(version, targetVersion) {\n                if (version && targetVersion) {\n                    var key = version + '__' + targetVersion;\n                    if (key in caches) {\n                        return caches[key];\n                    }\n                    version = toIntArray(version);\n                    targetVersion = toIntArray(targetVersion);\n                    for (var i = 0, n1, n2; i < version.length; i++) {\n                        n1 = targetVersion[i] || 0;\n                        n2 = version[i] || 0;\n                        if (n1 > n2) {\n                            caches[key] = -1;\n                            break;\n                        }\n                        if (n1 < n2) {\n                            caches[key] = 1;\n                            break;\n                        }\n                    }\n                    caches[key] = caches[key] || 0;\n                    return caches[key];\n                }\n                return 0;\n            }\n\n            function logSystemInfo() {\n                console.log(\"dd\" + '/SDKVersion: ' + SDKVersion);\n            }\n\n            function compareSystemVersion(targetVersion) {\n                return compareVersion(systemVersion, targetVersion);\n            }\n\n            function compareUCVersion(targetVersion) {\n                return compareVersion(UCVersion, targetVersion);\n            }\n\n            function compareDDSysVersion(targetVersion) {\n                return compareVersion(ddSystemVersion, targetVersion);\n            }\n\n            /***/\n        }),\n\n        /***/\n        \"./src/web-view/embed/api.tsx\":\n        /*!************************************!*\\\n          !*** ./src/web-view/embed/api.tsx ***!\n          \\************************************/\n        /*! exports provided: API, workerAPI */\n        /***/\n            (function(module, __webpack_exports__, __webpack_require__) {\n\n            \"use strict\";\n            __webpack_require__.r(__webpack_exports__);\n            /* harmony export (binding) */\n            __webpack_require__.d(__webpack_exports__, \"API\", function() { return API; });\n            /* harmony export (binding) */\n            __webpack_require__.d(__webpack_exports__, \"workerAPI\", function() { return workerAPI; });\n            /* harmony import */\n            var _bridge_shared_UI__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ../../bridge/shared/UI */ \"./src/bridge/shared/UI.tsx\");\n            /* harmony import */\n            var _bridge_shared_Media__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! ../../bridge/shared/Media */ \"./src/bridge/shared/Media.tsx\");\n            /* harmony import */\n            var _bridge_shared_Network__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! ../../bridge/shared/Network */ \"./src/bridge/shared/Network.tsx\");\n            /* harmony import */\n            var _bridge_shared_Location__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! ../../bridge/shared/Location */ \"./src/bridge/shared/Location.tsx\");\n            /* harmony import */\n            var _bridge_shared_BizCustomAP__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__( /*! ../../bridge/shared/BizCustomAP */ \"./src/bridge/shared/BizCustomAP.tsx\");\n\n\n\n\n\n            var g = self;\n            var API = {\n                alert: _bridge_shared_UI__WEBPACK_IMPORTED_MODULE_0__[\"alert\"],\n                showLoading: _bridge_shared_UI__WEBPACK_IMPORTED_MODULE_0__[\"showLoading\"],\n                hideLoading: _bridge_shared_UI__WEBPACK_IMPORTED_MODULE_0__[\"hideLoading\"],\n                previewImage: _bridge_shared_Media__WEBPACK_IMPORTED_MODULE_1__[\"previewImage\"],\n                chooseImage: _bridge_shared_Media__WEBPACK_IMPORTED_MODULE_1__[\"chooseImage\"],\n                getNetworkType: _bridge_shared_Network__WEBPACK_IMPORTED_MODULE_2__[\"getNetworkType\"],\n                openLocation: _bridge_shared_Location__WEBPACK_IMPORTED_MODULE_3__[\"openLocation\"],\n                openTaobao: Object(_bridge_shared_BizCustomAP__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(function() {\n                    return g.AlipayJSBridge.call;\n                })\n            };\n            var workerAPI = ['navigateTo', 'navigateBack', 'switchTab', 'reLaunch', 'redirectTo', 'getLocation'];\n\n            /***/\n        }),\n\n        /***/\n        \"./src/web-view/embed/index.tsx\":\n        /*!**************************************!*\\\n          !*** ./src/web-view/embed/index.tsx ***!\n          \\**************************************/\n        /*! exports provided: default */\n        /***/\n            (function(module, __webpack_exports__, __webpack_require__) {\n\n            \"use strict\";\n            __webpack_require__.r(__webpack_exports__);\n            /* harmony import */\n            var babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! babel-runtime/helpers/extends */ \"./node_modules/babel-runtime-loose/helpers/extends.js\");\n            /* harmony import */\n            var babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__);\n            /* harmony import */\n            var _api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! ./api */ \"./src/web-view/embed/api.tsx\");\n            /* harmony import */\n            var _utils_bridge__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! ../../utils/bridge */ \"./src/utils/bridge.tsx\");\n            /* harmony import */\n            var _utils_objectKeys__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! ../../utils/objectKeys */ \"./src/utils/objectKeys.tsx\");\n            /* harmony import */\n            var _utils_system__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__( /*! ../../utils/system */ \"./src/utils/system.tsx\");\n\n\n\n\n\n            var promise = new Promise(function(resolve) {\n                document.addEventListener('AlipayJSBridgeReady', resolve);\n            });\n            var id = 0;\n            var callPool = {};\n            var g = self;\n            var noop = function noop() {};\n            var handleParamsBeforeCall = function handleParamsBeforeCall(param, apiName) {\n                var newParam = babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({}, param);\n                var apiConfig = _api__WEBPACK_IMPORTED_MODULE_1__[\"API\"][apiName];\n                var callbackParam = {\n                    success: newParam.success || noop,\n                    fail: newParam.fail || noop,\n                    complete: newParam.complete || noop\n                };\n                delete newParam.success;\n                delete newParam.fail;\n                delete newParam.complete;\n                if (apiConfig && apiConfig.b) {\n                    apiConfig.b(newParam);\n                }\n                return {\n                    newParam: newParam,\n                    callbackParam: callbackParam,\n                    apiName: apiConfig.m ? apiConfig.m : apiName\n                };\n            };\n            var my = {\n                call: function call() {\n                    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n                        args[_key] = arguments[_key];\n                    }\n\n                    promise.then(function() {\n                        var _g$AlipayJSBridge;\n\n                        (_g$AlipayJSBridge = g.AlipayJSBridge).call.apply(_g$AlipayJSBridge, args);\n                    });\n                },\n                postMessage: function postMessage(detail) {\n                    promise.then(function() {\n                        var postDta = {\n                            type: 'message',\n                            detail: detail\n                        };\n                        // todo 10.1.20 ioså¥½å‘\n                        if (_utils_system__WEBPACK_IMPORTED_MODULE_4__[\"systemVersion\"] === '10.1.20' && _utils_system__WEBPACK_IMPORTED_MODULE_4__[\"isIOS\"]) {\n                            postDta = {\n                                type: 'getLocation',\n                                appXsubType: 'message',\n                                detail: detail\n                            };\n                        }\n                        g.AlipayJSBridge.call('postWebViewMessage', postDta);\n                    });\n                },\n                getEnv: function getEnv(callback) {\n                    // ä»£è¡¨æ³¨å…¥äº†AlipayJSBridge\n                    if (navigator.userAgent.indexOf('Nebula') === -1) {\n                        if (callback) {\n                            callback({ miniprogram: false });\n                        }\n                    } else {\n                        promise.then(function() {\n                            g.AlipayJSBridge.call('getEmbedWebViewEnv', function(res) {\n                                if (callback) {\n                                    callback(res);\n                                }\n                            });\n                        });\n                    }\n                }\n            };\n            _api__WEBPACK_IMPORTED_MODULE_1__[\"workerAPI\"].forEach(function(apiName) {\n                my[apiName] = function(param) {\n                    promise.then(function() {\n                        var newParam = babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({}, param);\n                        if (newParam.success || newParam.complete || newParam.fail) {\n                            callPool[++id] = babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({}, newParam);\n                            delete newParam.success;\n                            delete newParam.complete;\n                            delete newParam.fail;\n                        }\n                        g.AlipayJSBridge.call('postWebViewMessage', {\n                            type: apiName,\n                            callback: id,\n                            param: newParam\n                        });\n                    });\n                };\n            });\n            Object(_utils_objectKeys__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(_api__WEBPACK_IMPORTED_MODULE_1__[\"API\"]).forEach(function(apiName) {\n                var apiConfig = _api__WEBPACK_IMPORTED_MODULE_1__[\"API\"][apiName] || {};\n                my[apiName] = function(param) {\n                    var paramObj = handleParamsBeforeCall(param, apiName);\n                    promise.then(function() {\n                        if (apiConfig.d) {\n                            apiConfig.d(paramObj.newParam);\n                        } else if (param === undefined) {\n                            g.AlipayJSBridge.call(paramObj.apiName);\n                        } else {\n                            g.AlipayJSBridge.call(paramObj.apiName, paramObj.newParam, function(originRes) {\n                                var res = originRes;\n                                if (apiConfig.a) {\n                                    apiConfig.a(res);\n                                }\n                                Object(_utils_bridge__WEBPACK_IMPORTED_MODULE_2__[\"apCallback\"])(paramObj.callbackParam, res);\n                            });\n                        }\n                    });\n                };\n            });\n            document.addEventListener('onToWebViewMessage', function(e) {\n                var _e$data = e.data,\n                    callback = _e$data.callback,\n                    res = _e$data.res;\n\n                if (res.type === 'response') {\n                    if (callPool[callback]) {\n                        Object(_utils_bridge__WEBPACK_IMPORTED_MODULE_2__[\"apCallback\"])(callPool[callback], res.res);\n                        delete callPool[callback];\n                    }\n                } else if (res.type === 'message') {\n                    if (my.onMessage) {\n                        my.onMessage(JSON.parse(res.data));\n                    }\n                }\n            });\n            if (true) {\n                g.dd = my;\n            }\n            /* harmony default export */\n            __webpack_exports__[\"default\"] = (my);\n\n            /***/\n        })\n\n        /******/\n    })[\"default\"];","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\n\nvar Event = /** @class */ (function () {\r\n    function Event(type, target) {\r\n        this.target = target;\r\n        this.type = type;\r\n    }\r\n    return Event;\r\n}());\r\nvar ErrorEvent = /** @class */ (function (_super) {\r\n    __extends(ErrorEvent, _super);\r\n    function ErrorEvent(error, target) {\r\n        var _this = _super.call(this, 'error', target) || this;\r\n        _this.message = error.message;\r\n        _this.error = error;\r\n        return _this;\r\n    }\r\n    return ErrorEvent;\r\n}(Event));\r\nvar CloseEvent = /** @class */ (function (_super) {\r\n    __extends(CloseEvent, _super);\r\n    function CloseEvent(code, reason, target) {\r\n        if (code === void 0) { code = 1000; }\r\n        if (reason === void 0) { reason = ''; }\r\n        var _this = _super.call(this, 'close', target) || this;\r\n        _this.wasClean = true;\r\n        _this.code = code;\r\n        _this.reason = reason;\r\n        return _this;\r\n    }\r\n    return CloseEvent;\r\n}(Event));\n\n/*!\r\n * Reconnecting WebSocket\r\n * by Pedro Ladaria <pedro.ladaria@gmail.com>\r\n * https://github.com/pladaria/reconnecting-websocket\r\n * License MIT\r\n */\r\nvar getGlobalWebSocket = function () {\r\n    if (typeof WebSocket !== 'undefined') {\r\n        // @ts-ignore\r\n        return WebSocket;\r\n    }\r\n};\r\n/**\r\n * Returns true if given argument looks like a WebSocket class\r\n */\r\nvar isWebSocket = function (w) { return typeof w === 'function' && w.CLOSING === 2; };\r\nvar DEFAULT = {\r\n    maxReconnectionDelay: 10000,\r\n    minReconnectionDelay: 1000 + Math.random() * 4000,\r\n    minUptime: 5000,\r\n    reconnectionDelayGrowFactor: 1.3,\r\n    connectionTimeout: 4000,\r\n    maxRetries: Infinity,\r\n    debug: false,\r\n};\r\nvar ReconnectingWebSocket = /** @class */ (function () {\r\n    function ReconnectingWebSocket(url, protocols, options) {\r\n        if (options === void 0) { options = {}; }\r\n        var _this = this;\r\n        this._listeners = {\r\n            error: [],\r\n            message: [],\r\n            open: [],\r\n            close: [],\r\n        };\r\n        this._retryCount = -1;\r\n        this._shouldReconnect = true;\r\n        this._connectLock = false;\r\n        this._binaryType = 'blob';\r\n        this._closeCalled = false;\r\n        this._messageQueue = [];\r\n        /**\r\n         * An event listener to be called when the WebSocket connection's readyState changes to CLOSED\r\n         */\r\n        this.onclose = undefined;\r\n        /**\r\n         * An event listener to be called when an error occurs\r\n         */\r\n        this.onerror = undefined;\r\n        /**\r\n         * An event listener to be called when a message is received from the server\r\n         */\r\n        this.onmessage = undefined;\r\n        /**\r\n         * An event listener to be called when the WebSocket connection's readyState changes to OPEN;\r\n         * this indicates that the connection is ready to send and receive data\r\n         */\r\n        this.onopen = undefined;\r\n        this._handleOpen = function (event) {\r\n            _this._debug('open event');\r\n            var _a = _this._options.minUptime, minUptime = _a === void 0 ? DEFAULT.minUptime : _a;\r\n            clearTimeout(_this._connectTimeout);\r\n            _this._uptimeTimeout = setTimeout(function () { return _this._acceptOpen(); }, minUptime);\r\n            // @ts-ignore\r\n            _this._ws.binaryType = _this._binaryType;\r\n            // send enqueued messages (messages sent before websocket open event)\r\n            _this._messageQueue.forEach(function (message) { return _this._ws.send(message); });\r\n            _this._messageQueue = [];\r\n            if (_this.onopen) {\r\n                _this.onopen(event);\r\n            }\r\n            _this._listeners.open.forEach(function (listener) { return _this._callEventListener(event, listener); });\r\n        };\r\n        this._handleMessage = function (event) {\r\n            _this._debug('message event');\r\n            if (_this.onmessage) {\r\n                _this.onmessage(event);\r\n            }\r\n            _this._listeners.message.forEach(function (listener) { return _this._callEventListener(event, listener); });\r\n        };\r\n        this._handleError = function (event) {\r\n            _this._debug('error event', event.message);\r\n            _this._disconnect(undefined, event.message === 'TIMEOUT' ? 'timeout' : undefined);\r\n            if (_this.onerror) {\r\n                _this.onerror(event);\r\n            }\r\n            _this._debug('exec error listeners');\r\n            _this._listeners.error.forEach(function (listener) { return _this._callEventListener(event, listener); });\r\n            _this._connect();\r\n        };\r\n        this._handleClose = function (event) {\r\n            _this._debug('close event');\r\n            _this._clearTimeouts();\r\n            if (_this._shouldReconnect) {\r\n                _this._connect();\r\n            }\r\n            if (_this.onclose) {\r\n                _this.onclose(event);\r\n            }\r\n            _this._listeners.close.forEach(function (listener) { return _this._callEventListener(event, listener); });\r\n        };\r\n        this._url = url;\r\n        this._protocols = protocols;\r\n        this._options = options;\r\n        this._connect();\r\n    }\r\n    Object.defineProperty(ReconnectingWebSocket, \"CONNECTING\", {\r\n        get: function () {\r\n            return 0;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ReconnectingWebSocket, \"OPEN\", {\r\n        get: function () {\r\n            return 1;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ReconnectingWebSocket, \"CLOSING\", {\r\n        get: function () {\r\n            return 2;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ReconnectingWebSocket, \"CLOSED\", {\r\n        get: function () {\r\n            return 3;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ReconnectingWebSocket.prototype, \"CONNECTING\", {\r\n        get: function () {\r\n            return ReconnectingWebSocket.CONNECTING;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ReconnectingWebSocket.prototype, \"OPEN\", {\r\n        get: function () {\r\n            return ReconnectingWebSocket.OPEN;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ReconnectingWebSocket.prototype, \"CLOSING\", {\r\n        get: function () {\r\n            return ReconnectingWebSocket.CLOSING;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ReconnectingWebSocket.prototype, \"CLOSED\", {\r\n        get: function () {\r\n            return ReconnectingWebSocket.CLOSED;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ReconnectingWebSocket.prototype, \"binaryType\", {\r\n        get: function () {\r\n            return this._ws ? this._ws.binaryType : this._binaryType;\r\n        },\r\n        set: function (value) {\r\n            this._binaryType = value;\r\n            if (this._ws) {\r\n                // @ts-ignore\r\n                this._ws.binaryType = value;\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ReconnectingWebSocket.prototype, \"retryCount\", {\r\n        /**\r\n         * Returns the number or connection retries\r\n         */\r\n        get: function () {\r\n            return Math.max(this._retryCount, 0);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ReconnectingWebSocket.prototype, \"bufferedAmount\", {\r\n        /**\r\n         * The number of bytes of data that have been queued using calls to send() but not yet\r\n         * transmitted to the network. This value resets to zero once all queued data has been sent.\r\n         * This value does not reset to zero when the connection is closed; if you keep calling send(),\r\n         * this will continue to climb. Read only\r\n         */\r\n        get: function () {\r\n            var bytes = this._messageQueue.reduce(function (acc, message) {\r\n                if (typeof message === 'string') {\r\n                    acc += message.length; // not byte size\r\n                }\r\n                else if (message instanceof Blob) {\r\n                    acc += message.size;\r\n                }\r\n                else {\r\n                    acc += message.byteLength;\r\n                }\r\n                return acc;\r\n            }, 0);\r\n            return bytes + (this._ws ? this._ws.bufferedAmount : 0);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ReconnectingWebSocket.prototype, \"extensions\", {\r\n        /**\r\n         * The extensions selected by the server. This is currently only the empty string or a list of\r\n         * extensions as negotiated by the connection\r\n         */\r\n        get: function () {\r\n            return this._ws ? this._ws.extensions : '';\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ReconnectingWebSocket.prototype, \"protocol\", {\r\n        /**\r\n         * A string indicating the name of the sub-protocol the server selected;\r\n         * this will be one of the strings specified in the protocols parameter when creating the\r\n         * WebSocket object\r\n         */\r\n        get: function () {\r\n            return this._ws ? this._ws.protocol : '';\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ReconnectingWebSocket.prototype, \"readyState\", {\r\n        /**\r\n         * The current state of the connection; this is one of the Ready state constants\r\n         */\r\n        get: function () {\r\n            return this._ws ? this._ws.readyState : ReconnectingWebSocket.CONNECTING;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ReconnectingWebSocket.prototype, \"url\", {\r\n        /**\r\n         * The URL as resolved by the constructor\r\n         */\r\n        get: function () {\r\n            return this._ws ? this._ws.url : '';\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Closes the WebSocket connection or connection attempt, if any. If the connection is already\r\n     * CLOSED, this method does nothing\r\n     */\r\n    ReconnectingWebSocket.prototype.close = function (code, reason) {\r\n        if (code === void 0) { code = 1000; }\r\n        this._closeCalled = true;\r\n        this._shouldReconnect = false;\r\n        this._clearTimeouts();\r\n        if (!this._ws) {\r\n            this._debug('close enqueued: no ws instance');\r\n            return;\r\n        }\r\n        if (this._ws.readyState === this.CLOSED) {\r\n            this._debug('close: already closed');\r\n            return;\r\n        }\r\n        this._ws.close(code, reason);\r\n    };\r\n    /**\r\n     * Closes the WebSocket connection or connection attempt and connects again.\r\n     * Resets retry counter;\r\n     */\r\n    ReconnectingWebSocket.prototype.reconnect = function (code, reason) {\r\n        this._shouldReconnect = true;\r\n        this._closeCalled = false;\r\n        this._retryCount = -1;\r\n        if (!this._ws || this._ws.readyState === this.CLOSED) {\r\n            this._connect();\r\n        }\r\n        else {\r\n            this._disconnect(code, reason);\r\n            this._connect();\r\n        }\r\n    };\r\n    /**\r\n     * Enqueue specified data to be transmitted to the server over the WebSocket connection\r\n     */\r\n    ReconnectingWebSocket.prototype.send = function (data) {\r\n        if (this._ws && this._ws.readyState === this.OPEN) {\r\n            this._debug('send', data);\r\n            this._ws.send(data);\r\n        }\r\n        else {\r\n            this._debug('enqueue', data);\r\n            this._messageQueue.push(data);\r\n        }\r\n    };\r\n    /**\r\n     * Register an event handler of a specific event type\r\n     */\r\n    ReconnectingWebSocket.prototype.addEventListener = function (type, listener) {\r\n        if (this._listeners[type]) {\r\n            // @ts-ignore\r\n            this._listeners[type].push(listener);\r\n        }\r\n    };\r\n    /**\r\n     * Removes an event listener\r\n     */\r\n    ReconnectingWebSocket.prototype.removeEventListener = function (type, listener) {\r\n        if (this._listeners[type]) {\r\n            // @ts-ignore\r\n            this._listeners[type] = this._listeners[type].filter(function (l) { return l !== listener; });\r\n        }\r\n    };\r\n    ReconnectingWebSocket.prototype._debug = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        if (this._options.debug) {\r\n            // not using spread because compiled version uses Symbols\r\n            // tslint:disable-next-line\r\n            console.log.apply(console, ['RWS>'].concat(args));\r\n        }\r\n    };\r\n    ReconnectingWebSocket.prototype._getNextDelay = function () {\r\n        var _a = this._options, _b = _a.reconnectionDelayGrowFactor, reconnectionDelayGrowFactor = _b === void 0 ? DEFAULT.reconnectionDelayGrowFactor : _b, _c = _a.minReconnectionDelay, minReconnectionDelay = _c === void 0 ? DEFAULT.minReconnectionDelay : _c, _d = _a.maxReconnectionDelay, maxReconnectionDelay = _d === void 0 ? DEFAULT.maxReconnectionDelay : _d;\r\n        var delay = minReconnectionDelay;\r\n        if (this._retryCount > 0) {\r\n            delay =\r\n                minReconnectionDelay * Math.pow(reconnectionDelayGrowFactor, this._retryCount - 1);\r\n            if (delay > maxReconnectionDelay) {\r\n                delay = maxReconnectionDelay;\r\n            }\r\n        }\r\n        this._debug('next delay', delay);\r\n        return delay;\r\n    };\r\n    ReconnectingWebSocket.prototype._wait = function () {\r\n        var _this = this;\r\n        return new Promise(function (resolve) {\r\n            setTimeout(resolve, _this._getNextDelay());\r\n        });\r\n    };\r\n    ReconnectingWebSocket.prototype._getNextUrl = function (urlProvider) {\r\n        if (typeof urlProvider === 'string') {\r\n            return Promise.resolve(urlProvider);\r\n        }\r\n        if (typeof urlProvider === 'function') {\r\n            var url = urlProvider();\r\n            if (typeof url === 'string') {\r\n                return Promise.resolve(url);\r\n            }\r\n            if (url.then) {\r\n                return url;\r\n            }\r\n        }\r\n        throw Error('Invalid URL');\r\n    };\r\n    ReconnectingWebSocket.prototype._connect = function () {\r\n        var _this = this;\r\n        if (this._connectLock || !this._shouldReconnect) {\r\n            return;\r\n        }\r\n        this._connectLock = true;\r\n        var _a = this._options, _b = _a.maxRetries, maxRetries = _b === void 0 ? DEFAULT.maxRetries : _b, _c = _a.connectionTimeout, connectionTimeout = _c === void 0 ? DEFAULT.connectionTimeout : _c, _d = _a.WebSocket, WebSocket = _d === void 0 ? getGlobalWebSocket() : _d;\r\n        if (this._retryCount >= maxRetries) {\r\n            this._debug('max retries reached', this._retryCount, '>=', maxRetries);\r\n            return;\r\n        }\r\n        this._retryCount++;\r\n        this._debug('connect', this._retryCount);\r\n        this._removeListeners();\r\n        if (!isWebSocket(WebSocket)) {\r\n            throw Error('No valid WebSocket class provided');\r\n        }\r\n        this._wait()\r\n            .then(function () { return _this._getNextUrl(_this._url); })\r\n            .then(function (url) {\r\n            // close could be called before creating the ws\r\n            if (_this._closeCalled) {\r\n                _this._connectLock = false;\r\n                return;\r\n            }\r\n            _this._debug('connect', { url: url, protocols: _this._protocols });\r\n            _this._ws = _this._protocols\r\n                ? new WebSocket(url, _this._protocols)\r\n                : new WebSocket(url);\r\n            // @ts-ignore\r\n            _this._ws.binaryType = _this._binaryType;\r\n            _this._connectLock = false;\r\n            _this._addListeners();\r\n            _this._connectTimeout = setTimeout(function () { return _this._handleTimeout(); }, connectionTimeout);\r\n        });\r\n    };\r\n    ReconnectingWebSocket.prototype._handleTimeout = function () {\r\n        this._debug('timeout event');\r\n        this._handleError(new ErrorEvent(Error('TIMEOUT'), this));\r\n    };\r\n    ReconnectingWebSocket.prototype._disconnect = function (code, reason) {\r\n        if (code === void 0) { code = 1000; }\r\n        this._clearTimeouts();\r\n        if (!this._ws) {\r\n            return;\r\n        }\r\n        this._removeListeners();\r\n        try {\r\n            this._ws.close(code, reason);\r\n            this._handleClose(new CloseEvent(code, reason, this));\r\n        }\r\n        catch (error) {\r\n            // ignore\r\n        }\r\n    };\r\n    ReconnectingWebSocket.prototype._acceptOpen = function () {\r\n        this._debug('accept open');\r\n        this._retryCount = 0;\r\n    };\r\n    ReconnectingWebSocket.prototype._callEventListener = function (event, listener) {\r\n        if ('handleEvent' in listener) {\r\n            // @ts-ignore\r\n            listener.handleEvent(event);\r\n        }\r\n        else {\r\n            // @ts-ignore\r\n            listener(event);\r\n        }\r\n    };\r\n    ReconnectingWebSocket.prototype._removeListeners = function () {\r\n        if (!this._ws) {\r\n            return;\r\n        }\r\n        this._debug('removeListeners');\r\n        this._ws.removeEventListener('open', this._handleOpen);\r\n        this._ws.removeEventListener('close', this._handleClose);\r\n        this._ws.removeEventListener('message', this._handleMessage);\r\n        // @ts-ignore\r\n        this._ws.removeEventListener('error', this._handleError);\r\n    };\r\n    ReconnectingWebSocket.prototype._addListeners = function () {\r\n        if (!this._ws) {\r\n            return;\r\n        }\r\n        this._debug('addListeners');\r\n        this._ws.addEventListener('open', this._handleOpen);\r\n        this._ws.addEventListener('close', this._handleClose);\r\n        this._ws.addEventListener('message', this._handleMessage);\r\n        // @ts-ignore\r\n        this._ws.addEventListener('error', this._handleError);\r\n    };\r\n    ReconnectingWebSocket.prototype._clearTimeouts = function () {\r\n        clearTimeout(this._connectTimeout);\r\n        clearTimeout(this._uptimeTimeout);\r\n    };\r\n    return ReconnectingWebSocket;\r\n}());\n\nexport default ReconnectingWebSocket;\n"],"mappings":"AACA;;;;;;ACYA;;;;;;ACLA;;;;;AAiJA;;;;;AA2BA;;;;;AA4DA;;;;;AAuBA;;;;;AA8DA;;;;;AAwBA;;;;;AAwCA;;;;;AAqLA;;;;;AAwBA;;;;;AA4GA;;;;;AAgDA;;;;;;;ACpuBA;;;;;;;;;;;;;;;ACMA","sourceRoot":""}